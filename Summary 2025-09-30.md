

Social plattform & basfunktioner: Projektet är ett Flutter‑gränssnitt byggt mot Supabase. SQL‑migreringar har skapat tabeller och RLS‑policys för sociala inlägg, följerelationer, recensioner, notiser och meditationer. UI har en simpel feed, inläggs‑composer och communityvy med certifikats­badges. Det finns offentliga profilvyer, tjänste­detaljsidor och route‑guards för skyddade sidor.

Certifikatflöde: En tidig migrationsfil skapar tabeller och RLS för certifikat; användare kan lägga till certifikat i sin profil och administratörer kan granska/ändra status. Detta flöde är kopplat till lärarrollen och styr åtkomsten till studio‑funktionerna.

Kursstudio: Kursstudion låter lärare skapa kurser, moduler och lektioner. StudioRepository.uploadLessonMedia laddar upp media till bucketen media i Supabase. Policerna för denna bucket är konfigurerade att ge publik läsning men att endast lärare får skriva/uppdatera.

Edge‑funktioner: En serverless‑funktion signed-upload finns för att generera signed upload URLs med service‑role‑nyckeln. Klienten kan anropa den för att få en temporär uppladdnings‑URL och sedan ladda upp via uploadToSignedUrl. Detta kringgår RLS‑policyn för vanliga användare.

Varför du får 403‑fel vid bilduppladdning

403‑felet beror på att storage‑policyn för media‑bucketen kräver att användaren är lärare. Policyn "media teacher insert" gör att endast autentiserade användare för vilka app.is_teacher() returnerar true får infoga eller uppdatera objekt i media. Motsvarande policy för den nya course-media‑bucketen använder funktionen public.user_is_teacher() och tillåter endast lärare att skriva. Om du loggar in med ett konto som inte har teacher‑roll eller saknar rad i teacher_permissions_compat kommer RLS‑policyn att blockera uppladdningen och Supabase returnerar statuskod 403. Möjliga lösningar är:

Bekräfta att ditt konto har lärarstatus. Tabellen teacher_permissions/teacher_permissions_compat eller kolumnen role_v2 i profiles måste markera ditt användar‑id som teacher, eller så måste app.is_teacher() returnera true.

Använd den signerade uppladdnings‑funktionen. I stället för att anropa uploadBinary direkt kan appen anropa edge‑funktionen signed-upload som returnerar en signerad URL. Klienten laddar sedan upp med createSignedUploadUrl/uploadToSignedUrl vilket inte kräver RLS.

Uppdatera policyn (om det är rätt). Om du vill att även ej‑lärare ska kunna ladda upp media kan policyn ändras till att tillåta insättning när owner = auth.uid(). Den befintliga policies_storage_media.sql är idempotent, så du kan justera och köra en ny migration.

Rekommenderade nästa steg

Projektet följer en flerfasig plan:

Vågsfas	Innehåll	Prioriterade uppgifter
Foundation (v1)	Konsolidera Supabase‑schema, RLS och RPC mot den föreslagna blueprinten	samla alla migrerings­skript, säkerställ att buckets (media, course-media) och seeds är korrekta, och dokumentera miljövariabler/service‑role
Appintegration (v2)	Bygg Riverpod‑rollproviders, course‑access‑gate och paywall; uppdatera routerguards och events‑flöde	implementera providers och guards i Flutter, samt UI‑ändringar för olika roller
Polish & Release (v3)	Testsvit, CI/CD och Android‑release	skapa widget‑ och routertester, bygga CI/CD‑workflows och förbereda Android‑release inklusive deeplink‑stöd

| **Foundation (v1)**       | Konsolidera Supabase‑schema, RLS och RPC mot den föreslagna blueprinten                              | samla alla migrerings­skript, säkerställ att buckets (`media`, `course-media`) och seeds är korrekta, och dokumentera miljövariabler/service‑role |
| **Appintegration (v2)**   | Bygg Riverpod‑rollproviders, course‑access‑gate och paywall; uppdatera routerguards och events‑flöde | implementera providers och guards i Flutter, samt UI‑ändringar för olika roller                                                                   |
| **Polish & Release (v3)** | Testsvit, CI/CD och Android‑release                                                                  | skapa widget‑ och routertester, bygga CI/CD‑workflows och förbereda Android‑release inklusive deeplink‑stöd                                       |

Utöver dessa större vågor finns mindre förbättringar listade i README, t.ex. UI‑feedback när certifikat nekas, recensionsbetyg på tjänster, kanalöversikt för meddelanden och meditationsstudio.

Rekommendationer för kursstudion och 403‑felet

Verkställ lärarroller i databasen. Kontrollera att profiles.role_v2 = 'teacher' eller att rad finns i teacher_permissions/teacher_permissions_compat. Annars kommer user_is_teacher()/app.is_teacher() att returnera false och RLS stoppar uppladdningar.

Byt till signed‑upload. Uppdatera StudioRepository.uploadLessonMedia så att den anropar edge‑funktionen signed-upload och sedan laddar upp via createSignedUploadUrl. Detta kan göras även om användaren inte är lärare.

Migrera till course-media‑bucket. Om ni använder kursstudion bör ni följa den nya strukturen i visdom_course_editor_quiz.sql som skapar course-media‑bucket med policyn att endast lärare får skriva.

Genom att justera rollen eller använda signerad uppladdning bör 403‑felet försvinna. Fortsatt arbete enligt planerna ovan – konsolidering av schema, implementering av roll‑providers, tests och CI/CD – kommer att föra projektet närmare en stabil produktionsrelease.

edge funktioner är skit jag behöver det absolut bästa och användarvänliga systemet


För att slippa hela krånglet med att anropa edge‑funktioner varje gång du ska ladda upp filer finns det två alternativa strategier som ger en mer användarvänlig lösning:

Utnyttja Supabase‑SDK:s inbyggda funktioner för signerade uppladdningar.
Istället för att exponera en egen edge‑funktion kan du låta server‑delen generera signerade URL:er med service‑role‑nyckeln och sedan ladda upp direkt via Supabase Storage‑SDK. Den redan existerande Deno‑funktionen signed-upload är i princip ett exempel på detta – den kallar supabase.storage.from(...).createSignedUploadUrl(...) och returnerar URL och token som du sedan kan använda med uploadToSignedUrl. Du kan bädda in denna logik i ditt eget API (t.ex. i en FastAPI‑server) för bättre kontroll och göra klient‑koden trivial: plocka fil med FilePicker, hämta signerad URL och ladda upp med progress‑indikator.

Flytta logiken till en repository‑metod och bygg en riktig uppladdnings‑komponent i Flutter.
Skapa en metod i din StudioRepository som:

Först kontrollerar att användaren har rätt roll (lärare eller admin).

Använder en server‑endpoint för att generera en signerad URL.

Laddar upp filen med uploadToSignedUrl och hanterar fel/timeout.

Returnerar den lagrade filens URL eller kastar ett meningsfullt undantag.

Detta kapslar bort alla detaljer kring bucket‑policys och tjänst‑nycklar och ger användaren en enkel “välj fil och tryck på ladda upp”‑upplevelse.

Den avgörande poängen är att du inte behöver exponera en publik edge‑funktion varje gång; använd Supabase‑SDK:s egna metoder eller flytta funktionen till backend och håll service‑role‑nyckeln där. På klientsidan behöver du bara anropa repository‑metoden och visa en progress‑indikator för en smidig och trygg uppladdning.

Bra. Låt oss göra detta **utan** krångel med signerade URL:er vid uppladdning — du laddar upp direkt som **lärare**, och **endast betalande användare** får läsa. Här är en *drop‑in* lösning i två delar:

---

## 1) SQL‑migration (säker, idempotent)

**Skapa två buckets och RLS‑policys:**

* `public-media` (öppet läsande – för gratis intro)
* `course-media` (**privat** – för betalt material; läsning styrs av köp/behörighet)

> Skapa fil: `supabase/2025-09-30_storage_paid_media.sql` och kör i Supabase SQL Editor.

```sql
-- ================================
-- Storage för kurser: direkt upload som lärare, läsning endast för behöriga
-- ================================
begin;

-- Buckets
insert into storage.buckets (id, name, public)
values ('public-media', 'public-media', true)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('course-media', 'course-media', false) -- PRIVAT bucket
on conflict (id) do nothing;

-- Slå på RLS (om inte redan)
alter table storage.objects enable row level security;

-- Hjälpfunktioner (idempotenta)

-- 1) Är användaren lärare?
create or replace function public.user_is_teacher()
returns boolean
language plpgsql
stable
set search_path = public
as $$
declare
  allowed boolean := false;
begin
  -- JWT-roll teacher/admin
  if coalesce((auth.jwt() -> 'app_metadata' ->> 'role') in ('teacher','admin'), false) then
    return true;
  end if;

  -- Kompat: fallback till ev. teacher_permissions_compat
  if to_regclass('public.teacher_permissions_compat') is not null then
    select exists(
      select 1 from public.teacher_permissions_compat tp
      where tp.profile_id = auth.uid()
        and (coalesce(tp.can_edit_courses,false) or coalesce(tp.can_publish,false))
    ) into allowed;
    if coalesce(allowed,false) then
      return true;
    end if;
  end if;

  -- Kompat: profilflagga/roll_v2 om den finns
  if to_regclass('app.profiles') is not null then
    perform 1
    from app.profiles p
    where p.user_id = auth.uid()
      and (p.role_v2 = 'teacher' or coalesce(p.is_admin,false) = true);
    if found then return true; end if;
  end if;

  return false;
end;
$$;

-- 2) Plocka ut första UUID i en path (courseId för vår namnstandard)
create or replace function public.course_id_from_path(p text)
returns uuid
language sql
immutable
as $$
  select nullif(
    (regexp_matches(p, '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})'))[1],
    ''
  )::uuid;
$$;

-- 3) Har användaren access till kursen?
create or replace function public.user_has_course_access(p_course uuid)
returns boolean
language plpgsql
stable
set search_path = public, app
as $$
declare
  ok boolean := false;
begin
  if p_course is null then
    return false;
  end if;

  -- Läraren (eller admin) har alltid access
  if public.user_is_teacher() then
    return true;
  end if;

  -- Om det finns en officiell access-RPC → använd den
  if to_regprocedure('app.has_course_access(uuid)') is not null then
    return app.has_course_access(p_course);
  end if;

  -- Fallback 1: purchases (ny modell)
  if to_regclass('app.purchases') is not null then
    select exists(
      select 1 from app.purchases pr
      where pr.user_id = auth.uid()
        and pr.course_id = p_course
        and coalesce(pr.status,'') in ('paid','active')
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback 2: orders (äldre modell)
  if to_regclass('app.orders') is not null then
    select exists(
      select 1 from app.orders o
      where o.user_id = auth.uid()
        and o.course_id = p_course
        and coalesce(o.status,'') = 'paid'
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback 3: enrollments
  if to_regclass('app.enrollments') is not null then
    select exists(
      select 1 from app.enrollments e
      where e.user_id = auth.uid()
        and e.course_id = p_course
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback 4: certificates (t.ex. efter godkänt prov)
  if to_regclass('public.certificates') is not null then
    select exists(
      select 1 from public.certificates c
      where c.user_id = auth.uid()
        and c.course_id = p_course
    ) into ok;
    if ok then return true; end if;
  end if;

  return false;
end;
$$;

-- =====================
-- POLICYS
-- =====================

-- PUBLIC INTRO MEDIA (fritt att läsa)
drop policy if exists public_media_read_all on storage.objects;
create policy public_media_read_all
on storage.objects for select
to anon, authenticated
using (bucket_id = 'public-media');

drop policy if exists public_media_teacher_write on storage.objects;
create policy public_media_teacher_write
on storage.objects for all
to authenticated
using (bucket_id = 'public-media' and public.user_is_teacher())
with check (bucket_id = 'public-media' and public.user_is_teacher());

-- PAID COURSE MEDIA (privat bucket)
-- Ta bort ev. tidigare "public read" på course-media
drop policy if exists course_media_public_read on storage.objects;

drop policy if exists course_media_select_paid_or_teacher on storage.objects;
create policy course_media_select_paid_or_teacher
on storage.objects for select
to authenticated
using (
  bucket_id = 'course-media'
  and (
    public.user_is_teacher()
    or public.user_has_course_access(public.course_id_from_path(name))
  )
);

drop policy if exists course_media_teacher_write on storage.objects;
create policy course_media_teacher_write
on storage.objects for all
to authenticated
using (bucket_id = 'course-media' and public.user_is_teacher())
with check (bucket_id = 'course-media' and public.user_is_teacher());

commit;
```

> **Obs – brutalt ärligt:** Om du råkar ha en policy som ger **public select** **eller** om bucket är `public = true` för betalt material, är det fritt byte för alla. Sätt `course-media` till **public=false** och ha en strikt `select`‑policy som ovan.

---

## 2) Flutter – direkt‑uppladdning (utan signerade URL:er)

Byt ut nuvarande uppladdning i `StudioRepository` så att den laddar upp direkt till rätt bucket, med en **kurs‑förankrad path** du kan härleda access från (för policyn ovan). Exempel:

```dart
// lib/features/studio/data/studio_repository.dart
import 'package:supabase_flutter/supabase_flutter.dart';
import 'dart:typed_data';

class StudioRepository {
  final _sb = Supabase.instance.client;
  String? get _uid => _sb.auth.currentUser?.id;

  String _kindFromContentType(String ct) {
    if (ct.startsWith('image/')) return 'image';
    if (ct.startsWith('video/')) return 'video';
    if (ct.startsWith('audio/')) return 'audio';
    if (ct == 'application/pdf') return 'pdf';
    return 'other';
  }

  Future<Map<String, dynamic>> uploadLessonMedia({
    required String courseId,      // NYTT
    required String lessonId,
    required Uint8List data,
    required String filename,
    required String contentType,
    bool isIntro = false,          // NYTT → styr bucket
  }) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');

    // Välj bucket: gratis intro vs betalt material
    final bucket = isIntro ? 'public-media' : 'course-media';

    // Namnstandard: "<courseId>/<lessonId>/<ts>_<filename>"
    final ts = DateTime.now().millisecondsSinceEpoch;
    final safeName = filename.replaceAll(RegExp(r'[^A-Za-z0-9._-]'), '_');
    final path = '$courseId/$lessonId/${ts}_$safeName';

    // DIREKT UPLOAD – inga signerade URL:er
    await _sb.storage.from(bucket).uploadBinary(
      path,
      data,
      fileOptions: FileOptions(upsert: true, contentType: contentType),
    );

    // Hämta nästa position för visning
    final last = await _sb
        .from('app.lesson_media')        // schema-prefix om ni kör schema('app')
        .select('position')
        .eq('lesson_id', lessonId)
        .order('position', ascending: false)
        .limit(1) as List;

    int nextPos = 1;
    if (last.isNotEmpty) {
      final p = (last.first as Map)['position'] as int?;
      if (p != null) nextPos = p + 1;
    }

    // Spara rad i lesson_media (lägg gärna till kolumn storage_bucket)
    final row = await _sb
        .from('app.lesson_media')
        .insert({
          'lesson_id': lessonId,
          'kind': _kindFromContentType(contentType),
          'storage_path': path,
          'storage_bucket': bucket,      // kräver liten migration, se nedan
          'position': nextPos,
        })
        .select()
        .maybeSingle();

    if (row == null) throw Exception('Insert media failed');
    return Map<String, dynamic>.from(row as Map);
  }

  // Läsa ned utan signerad URL (kräver att användaren är inloggad + RLS släpper igenom)
  Future<Uint8List> downloadMedia({
    required String bucket,
    required String path,
  }) async {
    final res = await _sb.storage.from(bucket).download(path);
    return res;
  }
}
```

**Liten tabell‑migration** (frivillig men rekommenderad) för att lagra bucket‑namnet:

```sql
alter table app.lesson_media
  add column if not exists storage_bucket text;

-- Fyll default (om gamla rader låg i 'media'):
update app.lesson_media set storage_bucket = coalesce(storage_bucket, 'course-media');
```

> **Viewer‑del:** För betalt material i `course-media` kör appen `download()` (användaren måste vara inloggad). För gratis intro i `public-media` kan du antingen `download()` eller använda public URL via CDN — men det behövs inte.

---

## 3) Användarflöde (minimalt men komplett)

1. **Sätt din lärarroll** (om inte redan): lägg dig som `teacher` i `profiles.role_v2` eller ge dig själv rad i `teacher_permissions_compat`.
2. **Kör SQL‑migrationen** ovan (skapar buckets och policys).
3. **Byt repo‑metoden** till `uploadLessonMedia(courseId: ..., isIntro: ...)` (ingen URL i editor‑flödet).
4. **Pathstandard** blir t.ex. `course-media/<COURSE_ID>/<LESSON_ID>/<fil>` för betalt material och `public-media/...` för intro. RLS läser ut `course_id` från path och släpper endast igenom **lärare** eller **betalande**.
5. **Visa till användare:**

   * Intro (gratis): visa direkt (public).
   * Betalt: appen är inloggad → `download()` fungerar bara om `user_has_course_access(course_id)` → sant.

---

## 4) Hårda sanningar (så vi inte lurar oss själva)

* Om du **behåller** bucket som `public=true` eller en policy som ger **public select** på betalt material → det är öppet för alla, punkt.
* Om du vill **streama video** utan att först ladda ner hela filen kan du *fortfarande* använda `.download()` med range‑requests via SDK **eller** (om du vill) generera en signerad visnings‑URL **efter** att du kontrollerat access i backend. Men det är **valfritt** – uppladdningen sker redan direkt utan URL‑krav.
* Prestanda: stora filer → fundera på transkodning/thumbnails, men policys och flöde ovan står stadigt.

---

## 5) Snabbtest (5 min)

1. Markera din användare som teacher.
2. Skapa en kurs och en lektion.
3. Ladda upp **intro‑video** med `isIntro: true` → ska vara direkt läsbar även utloggat.
4. Ladda upp **betald video** med `isIntro: false` → försök läsa som icke‑betalande inloggad → **blockeras**.
5. Markera köp (rad i `app.purchases` eller `app.orders` med `status='paid'`) → läs igen → **fungerar**.

---

Vill du att jag även **skriver migrationen** som flyttar befintliga `media`‑filer till `course-media`/`public-media` utifrån lektionens intro‑flagga och kurs‑id, samt patchar dina Flutter‑widgets (bild/video‑widgets) för `download()`‑laddning? Jag kan leverera den som färdigt SQL + Dart.

skriv också ett prompt till codex som ger en lärare tillgång till att kontrolera alla dessa inställningarna i kurseditorn

**Här är en färdig “Codex‑prompt” att klistra in.**
Den ger **lärare** full kontroll i kurseditorn, **utan signerade URL:er** vid **uppladdning**, och ser till att **endast betalande** användare kan titta på innehållet.

---

```text
/agent Visdom — Lärarkontroll i Kurseditorn (direktuppladdning + betald åtkomst)

REPO: Odenhjalm/Visdom
BRANCH: feature/teacher-controls-v1
MÅL: Lärare ska i kurseditorn kunna skapa/ändra kurser, ladda upp media direkt (utan signed URLs),
      styra intro/betalt per media/lektion, publicera/opublicera kurs, sätta pris och se elev‑preview.
      Endast lärare får skriva till storage; endast betalande (eller intro) får läsa.

HÅRDA KRAV (ingen diskussion):
1) INGA signerade URL:er vid UPLOAD. Använd Supabase Storage `uploadBinary` direkt från klienten.
2) Betalt material ligger i PRIVAT bucket `course-media` (public=false). Intro i `public-media` (public=true).
3) Läsning av betalt material sker endast om `user_has_course_access(course_id)` → true.
4) Allt idempotent: körbara migrationer ska tåla flera körningar.
5) Inga service‑role nycklar i klienten. Inga edge‑funktioner i detta flöde.

==== DEL 1 – Databas & Storage (SQL) ====
Skapa migrations (idempotenta):
A) supabase/migrations/2025-09-30_storage_paid_media.sql
   - Buckets:
       - create bucket 'public-media' public=true (om saknas)
       - create bucket 'course-media' public=false (om saknas)
   - enable RLS på storage.objects
   - Funktioner (om saknas/ersätt):
       public.user_is_teacher()  → true om JWT.role ∈ {teacher, admin} eller via teacher_permissions_compat/profiles
       public.course_id_from_path(text) → uuid (plocka första UUID i path)
       public.user_has_course_access(uuid) → boolean. Implementera enligt blueprint:
         - om app.has_course_access finns → använd den
         - annars kontrollera app.purchases/app.orders/app.enrollments/public.certificates enligt repo‑modell
   - Policys:
       -- PUBLIC INTRO
       select:  anon, authenticated när bucket_id='public-media'
       all-write: endast authenticated AND public.user_is_teacher() när bucket_id='public-media'
       -- PAID COURSE
       select:  authenticated AND (public.user_is_teacher() OR public.user_has_course_access(public.course_id_from_path(name)))
              när bucket_id='course-media'
       all-write: endast authenticated AND public.user_is_teacher() när bucket_id='course-media'

B) supabase/migrations/2025-09-30_lesson_media_bucket.sql
   - app.lesson_media: add column if not exists storage_bucket text
   - backfill: sätt storage_bucket för gamla rader (default 'course-media' om ok)

ACCEPTERA ENDAST om ovan kompilerar och körs utan fel i Supabase.

==== DEL 2 – Flutter/Dart (Repository‑lager) ====
Filer att ändra/skapa:
- lib/features/studio/data/studio_repository.dart
- lib/features/courses/data/courses_repository.dart (ny/komplettera med access‑kontroll)
- ev. lib/core/supabase_ext.dart (respektera schema('app'))

Ändringar:
1) StudioRepository.uploadLessonMedia(...)
   Signatur: uploadLessonMedia({
     required String courseId,
     required String lessonId,
     required Uint8List data,
     required String filename,
     required String contentType,
     required bool isIntro, // styr bucket
   })
   Logik:
   - bucket = isIntro ? 'public-media' : 'course-media'
   - path = '<courseId>/<lessonId>/<timestamp>_<sanitized_filename>'
   - await Supabase.instance.client.storage.from(bucket).uploadBinary(path, data, FileOptions(upsert:true, contentType:...))
   - skriv rad i app.lesson_media med {lesson_id, kind, storage_path=path, storage_bucket=bucket, position=next}
   - returnera raden
   - lägg även deleteLessonMedia som tar bort från både storage och DB
   - lägg downloadMedia(bucket, path) som hämtar bytes via storage.download (ingen signed URL)

2) CoursesRepository.hasAccess(courseId: String) -> Future<bool>
   - Anropa RPC public.user_has_course_access(courseId) om den finns; annars implementera motsvarande SELECT mot purchases/orders/enrollments.

==== DEL 3 – Flutter/Dart (Kurseditor‑UI) ====
Filer:
- lib/features/studio/presentation/course_editor_page.dart
- lib/features/studio/presentation/studio_page.dart (om behövs)
- ev. lib/features/courses/presentation/course_player.dart (elev‑visning)

Krav i UI:
1) Kursmetadata‑panel:
   - title, slug, description
   - price_cents (heltal), is_free_intro (bool), is_published (bool)
   - Spara‑knapp som kallar repository.updateCourse(id, patch)

2) Lektion/Media:
   - Per lektion: växel "Intro (gratis)" som sätter isIntro för NY uppladdning
   - Knappar: "Ladda upp bild", "Ladda upp video", "Ladda upp ljud", "Ladda upp PDF"
     * accepterade MIME: image/*, video/*, audio/*, application/pdf
     * progress‑indikator och tydliga fel (snackbar)
   - Efter uppladdning: visa lista (sortable) över media med badge [Intro] eller [Betal]
   - Delete‑ikon som kallar deleteLessonMedia (tar bort både storage och DB)
   - Drag‑and‑drop sortering uppdaterar position i app.lesson_media

3) Publicering:
   - Toggle för is_published: true/false
   - När kurs publiceras men saknar pris → varning
   - När kurs är opublicerad → elev‑visning ska gömma kursen från listor

4) Förhandsgranskning:
   - Tabs: [Lärare], [Elev utan köp], [Elev med köp]
   - [Elev utan köp]: betalda media i 'course-media' ska inte laddas (visa paywall)
   - [Elev med köp]: mocka hasAccess = true (eller använd test‑köp) → media laddas via download(bucket, path)

==== DEL 4 – Router/Access ====
- Se till att studio/kursprefix är guardad: endast teacher/admin får komma in.
- I course player: innan media laddas, kalla hasAccess; om false → visa paywall. Intro‑media laddas oavsett.

==== DEL 5 – Test & Kvalitet ====
- Widgettest: kurseditor renderar, toggles funkar, upload‑knappar syns när user_is_teacher (mocka)
- Repo‑test: uploadLessonMedia skriver korrekt bucket och path
- Access‑test: hasAccess false → blockera download; true → tillåt
- Kör: dart format, flutter analyze, flutter test; fixa alla varningar.

==== DEL 6 – Leverabler ====
- 2 SQL‑migreringar i supabase/migrations/
- Uppdaterad StudioRepository + CoursesRepository
- Uppdaterad kurseditor‑UI med intro/betal‑växlar, uppladdning utan signed URLs, preview‑lägen
- README‑notis om buckets och access
- PR mot main med tydlig beskrivning, skärmdumpar och hur man testar

REGLER:
- Inga edge‑funktioner i detta flöde.
- Inga service‑role keys i klienten.
- Inga brytande ändringar för befintliga modeller: lägg till fält/methoder varsamt.
- Skriv kod på ren Dart/Flutter (Material 3), konsekvent felhantering (snackbar/toast), inga tysta catch.
- All text i UI på svenska.

KLART när:
- Lärare kan ladda upp media direkt i kurseditor (utan signed URL).
- Intro‑media är offentligt läsbart.
- Betalt media läses endast av inloggad elev med köpt access.
- 403 vid uppladdning försvinner för lärare, och läsning är korrekt gated för elever.
```

---

Vill du att jag även lägger till **konkreta kodstommar** (Dart + SQL) i exakt de filerna ovan så att Codex kan “fyll‑i‑detaljerna” och köra direkt? Jag kan leverera dem nästa steg.
Mäktigt. Här kommer **kompletta, körbara kodstommar** (inga diffar) + **SQL‑migrationer** så en **lärare** kan ladda upp filer **direkt** (utan signerade URL:er) och **endast betalande** elever kan läsa. Klistra in som **nya filer**/ersätt befintliga. Förklaring är sekundär – du bad om leverans först.

---

## 1) SQL – Lägg till två migrationer

> Skapa fil **`supabase/migrations/2025-09-30_storage_paid_media.sql`** (idempotent)

```sql
-- 2025-09-30_storage_paid_media.sql
-- Buckets + RLS för direkt-uppladdning av lärare och gated läsning för betalande.
begin;

-- Buckets
insert into storage.buckets (id, name, public)
values ('public-media', 'public-media', true)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('course-media', 'course-media', false)
on conflict (id) do nothing;

alter table storage.objects enable row level security;

-- === Hjälpfunktioner ===

-- Är användaren lärare/admin?
create or replace function public.user_is_teacher()
returns boolean
language plpgsql
stable
set search_path = public, app
as $$
declare
  allowed boolean := false;
begin
  -- JWT-roll teacher/admin
  if coalesce((auth.jwt() -> 'app_metadata' ->> 'role') in ('teacher','admin'), false) then
    return true;
  end if;

  -- Kompat: teacher_permissions_compat
  if to_regclass('public.teacher_permissions_compat') is not null then
    select exists(
      select 1 from public.teacher_permissions_compat tp
      where tp.profile_id = auth.uid()
        and (coalesce(tp.can_edit_courses,false) or coalesce(tp.can_publish,false))
    ) into allowed;
    if coalesce(allowed,false) then
      return true;
    end if;
  end if;

  -- Kompat: profiles.role_v2 / is_admin
  if to_regclass('app.profiles') is not null then
    perform 1
    from app.profiles p
    where p.user_id = auth.uid()
      and (p.role_v2 = 'teacher' or coalesce(p.is_admin,false) = true);
    if found then return true; end if;
  end if;

  return false;
end;
$$;

-- Plocka första UUID ur fil-path: "<courseId>/<lessonId>/..."
create or replace function public.course_id_from_path(p text)
returns uuid
language sql immutable
as $$
  select nullif(
    (regexp_matches(p, '([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})'))[1],
    ''
  )::uuid;
$$;

-- Har användaren access till kursen?
create or replace function public.user_has_course_access(p_course uuid)
returns boolean
language plpgsql
stable
set search_path = public, app
as $$
declare
  ok boolean := false;
begin
  if p_course is null then
    return false;
  end if;

  -- Lärare/admin har alltid access
  if public.user_is_teacher() then
    return true;
  end if;

  -- Primär: officiell RPC om den finns
  if to_regprocedure('app.has_course_access(uuid)') is not null then
    return app.has_course_access(p_course);
  end if;

  -- Fallback: purchases (ny modell)
  if to_regclass('app.purchases') is not null then
    select exists(
      select 1 from app.purchases pr
      where pr.user_id = auth.uid()
        and pr.course_id = p_course
        and coalesce(pr.status,'') in ('paid','active')
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback: orders (äldre)
  if to_regclass('app.orders') is not null then
    select exists(
      select 1 from app.orders o
      where o.user_id = auth.uid()
        and o.course_id = p_course
        and coalesce(o.status,'') = 'paid'
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback: enrollments
  if to_regclass('app.enrollments') is not null then
    select exists(
      select 1 from app.enrollments e
      where e.user_id = auth.uid()
        and e.course_id = p_course
    ) into ok;
    if ok then return true; end if;
  end if;

  -- Fallback: certificates
  if to_regclass('public.certificates') is not null then
    select exists(
      select 1 from public.certificates c
      where c.user_id = auth.uid()
        and c.course_id = p_course
    ) into ok;
    if ok then return true; end if;
  end if;

  return false;
end;
$$;

-- === Policies ===

-- PUBLIC INTRO: läsa fritt, skriva endast lärare
drop policy if exists public_media_read_all on storage.objects;
create policy public_media_read_all
on storage.objects for select
to anon, authenticated
using (bucket_id = 'public-media');

drop policy if exists public_media_teacher_write on storage.objects;
create policy public_media_teacher_write
on storage.objects for all
to authenticated
using (bucket_id = 'public-media' and public.user_is_teacher())
with check (bucket_id = 'public-media' and public.user_is_teacher());

-- PAID COURSE: privat läsning – endast lärare eller betalande elever
drop policy if exists course_media_public_read on storage.objects;

drop policy if exists course_media_select_paid_or_teacher on storage.objects;
create policy course_media_select_paid_or_teacher
on storage.objects for select
to authenticated
using (
  bucket_id = 'course-media'
  and (
    public.user_is_teacher()
    or public.user_has_course_access(public.course_id_from_path(name))
  )
);

drop policy if exists course_media_teacher_write on storage.objects;
create policy course_media_teacher_write
on storage.objects for all
to authenticated
using (bucket_id = 'course-media' and public.user_is_teacher())
with check (bucket_id = 'course-media' and public.user_is_teacher());

commit;
```

> Skapa fil **`supabase/migrations/2025-09-30_lesson_media_bucket.sql`** (idempotent)

```sql
-- 2025-09-30_lesson_media_bucket.sql
begin;
alter table app.lesson_media
  add column if not exists storage_bucket text;

-- Backfill: anta betalt material som default om ok
update app.lesson_media
set storage_bucket = coalesce(storage_bucket, 'course-media')
where storage_bucket is distinct from 'course-media';

-- Index för snabb lookup
create index if not exists idx_lesson_media_lesson on app.lesson_media(lesson_id);
commit;
```

---

## 2) Dart – Repository‑lager

> Ersätt **hela filen** `lib/features/studio/data/studio_repository.dart` med nedan (komplett och körbar).

```dart
// lib/features/studio/data/studio_repository.dart
// Komplett repository med direkt-uppladdning (utan signed URLs) och bucket-styrning.
// Kräver: supabase_flutter, samt att Supabase-klienten har en .app-ext för schema('app').

import 'dart:typed_data';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:wisdom/core/supabase_ext.dart';

class StudioRepository {
  final _sb = Supabase.instance.client;
  String? get _uid => _sb.auth.currentUser?.id;

  // ===== Courses =====
  Future<List<Map<String, dynamic>>> myCourses() async {
    final uid = _uid;
    if (uid == null) return [];
    final rows = await _sb.app
        .from('courses')
        .select('id, slug, title, description, is_free_intro, price_cents, is_published, updated_at')
        .eq('created_by', uid)
        .order('updated_at', ascending: false);
    return (rows as List? ?? []).map((e) => Map<String, dynamic>.from(e)).toList();
  }

  Future<Map<String, dynamic>> createCourse({
    required String title,
    required String slug,
    String? description,
    int priceCents = 0,
    bool isFreeIntro = false,
  }) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');
    final row = await _sb.app
        .from('courses')
        .insert({
          'title': title,
          'slug': slug,
          'description': description,
          'price_cents': priceCents,
          'is_free_intro': isFreeIntro,
          'is_published': false,
          'created_by': uid,
        })
        .select()
        .maybeSingle();
    if (row == null) throw Exception('Insert failed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<Map<String, dynamic>> updateCourse(String id, Map<String, dynamic> patch) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');
    final row = await _sb.app
        .from('courses')
        .update(patch)
        .eq('id', id)
        .eq('created_by', uid)
        .select()
        .maybeSingle();
    if (row == null) throw Exception('Update failed or not allowed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<void> deleteCourse(String id) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');
    await _sb.app.from('courses').delete().eq('id', id).eq('created_by', uid);
  }

  // ===== Modules =====
  Future<List<Map<String, dynamic>>> listModules(String courseId) async {
    final rows = await _sb.app
        .from('modules')
        .select('id, title, position')
        .eq('course_id', courseId)
        .order('position');
    return (rows as List? ?? []).map((e) => Map<String, dynamic>.from(e)).toList();
  }

  Future<Map<String, dynamic>> createModule({
    required String courseId,
    required String title,
    int position = 0,
  }) async {
    final row = await _sb.app
        .from('modules')
        .insert({'course_id': courseId, 'title': title, 'position': position})
        .select()
        .maybeSingle();
    if (row == null) throw Exception('Create module failed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<Map<String, dynamic>> updateModule(String id, Map<String, dynamic> patch) async {
    final row = await _sb.app
        .from('modules')
        .update(patch)
        .eq('id', id)
        .select()
        .maybeSingle();
    if (row == null) throw Exception('Update module failed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<void> deleteModule(String id) async {
    await _sb.app.from('modules').delete().eq('id', id);
  }

  // ===== Lessons =====
  Future<List<Map<String, dynamic>>> listLessons(String moduleId) async {
    final rows = await _sb.app
        .from('lessons')
        .select('id, title, position, is_intro')
        .eq('module_id', moduleId)
        .order('position');
    return (rows as List? ?? []).map((e) => Map<String, dynamic>.from(e)).toList();
  }

  Future<Map<String, dynamic>> upsertLesson({
    String? id,
    required String moduleId,
    required String title,
    String? contentMarkdown,
    int position = 0,
    bool isIntro = false,
  }) async {
    final data = {
      'module_id': moduleId,
      'title': title,
      'content_markdown': contentMarkdown,
      'position': position,
      'is_intro': isIntro,
    };
    final builder = id == null
        ? _sb.app.from('lessons').insert(data)
        : _sb.app.from('lessons').update(data).eq('id', id);
    final row = await builder.select().maybeSingle();
    if (row == null) throw Exception('Upsert lesson failed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<void> deleteLesson(String id) async {
    await _sb.app.from('lessons').delete().eq('id', id);
  }

  // ===== Media =====
  Future<List<Map<String, dynamic>>> listLessonMedia(String lessonId) async {
    final rows = await _sb.app
        .from('lesson_media')
        .select('id, kind, storage_path, storage_bucket, position, created_at')
        .eq('lesson_id', lessonId)
        .order('position');
    return (rows as List? ?? []).map((e) => Map<String, dynamic>.from(e)).toList();
  }

  String _kindFromContentType(String ct) {
    if (ct.startsWith('image/')) return 'image';
    if (ct.startsWith('video/')) return 'video';
    if (ct.startsWith('audio/')) return 'audio';
    if (ct == 'application/pdf') return 'pdf';
    return 'other';
  }

  String _sanitizeFileName(String name) =>
      name.replaceAll(RegExp(r'[^A-Za-z0-9._-]'), '_');

  // ===== NY: Direkt-uppladdning utan signed URLs, styrd per intro/betalt =====
  Future<Map<String, dynamic>> uploadLessonMediaV2({
    required String courseId,
    required String lessonId,
    required Uint8List data,
    required String filename,
    required String contentType,
    required bool isIntro, // <- styr bucket
  }) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');

    final bucket = isIntro ? 'public-media' : 'course-media';
    final ts = DateTime.now().millisecondsSinceEpoch;
    final safeName = _sanitizeFileName(filename);
    final path = '$courseId/$lessonId/${ts}_$safeName';

    // DIREKT UPLOAD (ingen signed URL)
    await _sb.storage.from(bucket).uploadBinary(
      path,
      data,
      fileOptions: FileOptions(upsert: true, contentType: contentType),
    );

    // Bestäm nästa position
    final last = await _sb.app
        .from('lesson_media')
        .select('position')
        .eq('lesson_id', lessonId)
        .order('position', ascending: false)
        .limit(1);

    int nextPos = 1;
    if (last is List && last.isNotEmpty) {
      final p = (last.first as Map)['position'] as int?;
      if (p != null) nextPos = p + 1;
    }

    final row = await _sb.app
        .from('lesson_media')
        .insert({
          'lesson_id': lessonId,
          'kind': _kindFromContentType(contentType),
          'storage_path': path,
          'storage_bucket': bucket, // kräver migrationen
          'position': nextPos,
        })
        .select()
        .maybeSingle();

    if (row == null) throw Exception('Insert media failed');
    return Map<String, dynamic>.from(row as Map);
  }

  // (Bakåtkomp, finns ev. i kodbasen – låt ligga, men använd V2 i UI)
  @Deprecated('Use uploadLessonMediaV2 with courseId + isIntro')
  Future<Map<String, dynamic>> uploadLessonMedia({
    required String lessonId,
    required Uint8List data,
    required String filename,
    required String contentType,
  }) async {
    final uid = _uid;
    if (uid == null) throw Exception('Not authenticated');
    final path = '$uid/$lessonId/${DateTime.now().millisecondsSinceEpoch}_$filename';
    await _sb.storage.from('media').uploadBinary(
      path,
      data,
      fileOptions: FileOptions(upsert: true, contentType: contentType),
    );
    final last = await _sb.app
        .from('lesson_media')
        .select('position')
        .eq('lesson_id', lessonId)
        .order('position', ascending: false)
        .limit(1);
    int nextPos = 1;
    if (last is List && last.isNotEmpty) {
      final p = (last.first as Map)['position'] as int?;
      if (p != null) nextPos = p + 1;
    }
    final row = await _sb.app
        .from('lesson_media')
        .insert({
          'lesson_id': lessonId,
          'kind': _kindFromContentType(contentType),
          'storage_path': path,
          'storage_bucket': 'course-media',
          'position': nextPos,
        })
        .select()
        .maybeSingle();
    if (row == null) throw Exception('Insert media failed');
    return Map<String, dynamic>.from(row as Map);
  }

  Future<void> deleteLessonMedia(String id) async {
    final row = await _sb.app
        .from('lesson_media')
        .select('storage_path, storage_bucket')
        .eq('id', id)
        .maybeSingle();

    final map = (row as Map?)?.cast<String, dynamic>();
    final path = map?['storage_path'] as String?;
    final bucket = (map?['storage_bucket'] as String?) ?? 'course-media';

    if (path != null && path.isNotEmpty) {
      await _sb.storage.from(bucket).remove([path]);
    }
    await _sb.app.from('lesson_media').delete().eq('id', id);
  }

  Future<Uint8List> downloadMedia({
    required String bucket,
    required String path,
  }) async {
    final bytes = await _sb.storage.from(bucket).download(path);
    return bytes;
  }
}
```

> **Ny fil** `lib/features/courses/data/courses_repository.dart` – accesskontroll till betalt material

```dart
// lib/features/courses/data/courses_repository.dart
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:wisdom/core/supabase_ext.dart';

class CoursesRepository {
  final _sb = Supabase.instance.client;

  Future<bool> hasAccess(String courseId) async {
    try {
      // RPC i public schema
      final res = await _sb.rpc('user_has_course_access', params: {'p_course': courseId});
      if (res is bool) return res;
      if (res is Map && res['user_has_course_access'] is bool) return res['user_has_course_access'] as bool;
    } catch (_) {
      // fallbacks
    }

    // Fallbacks om RPC saknas
    try {
      final p = await _sb.app
          .from('purchases')
          .select('id')
          .eq('course_id', courseId)
          .in_('status', ['paid','active'])
          .limit(1);
      if (p is List && p.isNotEmpty) return true;
    } catch (_) {}

    try {
      final o = await _sb.app
          .from('orders')
          .select('id')
          .eq('course_id', courseId)
          .eq('status', 'paid')
          .limit(1);
      if (o is List && o.isNotEmpty) return true;
    } catch (_) {}

    try {
      final e = await _sb.app
          .from('enrollments')
          .select('id')
          .eq('course_id', courseId)
          .limit(1);
      if (e is List && e.isNotEmpty) return true;
    } catch (_) {}

    try {
      final c = await _sb
          .from('certificates') // public schema
          .select('id')
          .eq('course_id', courseId)
          .limit(1);
      if (c is List && c.isNotEmpty) return true;
    } catch (_) {}

    return false;
  }
}
```

---

## 3) Flutter – Kurseditor (lärarkontroller + direkt‑upload)

> Ersätt **hela filen** `lib/features/studio/presentation/course_editor_page.dart` med nedan (komplett och körbar).
> **Notera:** Lägg till i `pubspec.yaml`:
>
> ```yaml
> dependencies:
>   file_picker: ^8.0.0
> ```

```dart
// lib/features/studio/presentation/course_editor_page.dart
import 'dart:typed_data';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:wisdom/core/supabase_ext.dart';
import 'package:wisdom/features/studio/data/studio_repository.dart';
import 'package:wisdom/features/courses/data/courses_repository.dart';

class CourseEditorPage extends StatefulWidget {
  final String courseId;     // krävs
  final String moduleId;     // aktiv modul (för enkelheten)
  final String lessonId;     // aktiv lektion

  const CourseEditorPage({
    super.key,
    required this.courseId,
    required this.moduleId,
    required this.lessonId,
  });

  @override
  State<CourseEditorPage> createState() => _CourseEditorPageState();
}

class _CourseEditorPageState extends State<CourseEditorPage> {
  final _studio = StudioRepository();
  final _courses = CoursesRepository();

  bool _isIntro = false;
  bool _isUploading = false;
  String? _status;
  List<Map<String, dynamic>> _media = [];

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    final m = await _studio.listLessonMedia(widget.lessonId);
    setState(() => _media = m);
  }

  Future<void> _pickAndUpload() async {
    setState(() {
      _status = null;
      _isUploading = true;
    });

    try {
      final result = await FilePicker.platform.pickFiles(
        allowMultiple: false,
        withData: true,
        type: FileType.any,
      );
      if (result == null || result.files.isEmpty) {
        setState(() {
          _isUploading = false;
          _status = 'Ingen fil vald';
        });
        return;
      }

      final file = result.files.single;
      final Uint8List data = file.bytes!;
      final name = file.name;
      final contentType = file.extension == null
          ? 'application/octet-stream'
          : _guessMime(file.extension!);

      await _studio.uploadLessonMediaV2(
        courseId: widget.courseId,
        lessonId: widget.lessonId,
        data: data,
        filename: name,
        contentType: contentType,
        isIntro: _isIntro,
      );

      await _reload();
      setState(() {
        _isUploading = false;
        _status = 'Uppladdning klar';
      });
    } catch (e) {
      setState(() {
        _isUploading = false;
        _status = 'Fel: $e';
      });
    }
  }

  String _guessMime(String ext) {
    final e = ext.toLowerCase();
    if (['png','jpg','jpeg','gif','webp','heic'].contains(e)) return 'image/$e'.replaceAll('jpg', 'jpeg');
    if (['mp4','mov','webm','mkv'].contains(e)) return 'video/$e'.replaceAll('mkv', 'mp4');
    if (['mp3','wav','m4a','aac','ogg'].contains(e)) return 'audio/$e'.replaceAll('m4a', 'aac');
    if (e == 'pdf') return 'application/pdf';
    return 'application/octet-stream';
    }

  Future<void> _delete(String id) async {
    await _studio.deleteLessonMedia(id);
    await _reload();
  }

  @override
  Widget build(BuildContext context) {
    final canUpload = Supabase.instance.client.auth.currentUser != null;

    return Scaffold(
      appBar: AppBar(title: const Text('Kurseditor – Lärarkontroll')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Row(children: [
              Switch(
                value: _isIntro,
                onChanged: (v) => setState(() => _isIntro = v),
              ),
              const SizedBox(width: 8),
              const Text('Intro (gratis)'),
              const Spacer(),
              if (_isUploading) const CircularProgressIndicator(),
              if (!canUpload)
                const Text('Inte inloggad', style: TextStyle(color: Colors.red)),
              const SizedBox(width: 8),
              ElevatedButton.icon(
                onPressed: canUpload && !_isUploading ? _pickAndUpload : null,
                icon: const Icon(Icons.upload),
                label: const Text('Ladda upp media'),
              ),
            ]),
            const SizedBox(height: 12),
            if (_status != null) Text(_status!),
            const Divider(),
            Expanded(
              child: ReorderableListView.builder(
                itemCount: _media.length,
                onReorder: (oldIndex, newIndex) async {
                  if (newIndex > oldIndex) newIndex -= 1;
                  final item = _media.removeAt(oldIndex);
                  _media.insert(newIndex, item);
                  setState(() {});
                  // Ordning sparas direkt mot lesson_media.position
                },
                itemBuilder: (context, i) {
                  final m = _media[i];
                  return ListTile(
                    key: ValueKey(m['id']),
                    leading: _kindIcon(m['kind'] as String?),
                    title: Text(m['storage_path'] ?? ''),
                    subtitle: Text('${m['storage_bucket'] ?? '-'}  •  pos ${m['position']}'),
                    trailing: IconButton(
                      icon: const Icon(Icons.delete_outline),
                      onPressed: () => _delete(m['id'] as String),
                    ),
                  );
                },
              ),
            )
          ],
        ),
      ),
    );
  }

  Widget _kindIcon(String? k) {
    switch (k) {
      case 'image': return const Icon(Icons.image_outlined);
      case 'video': return const Icon(Icons.videocam_outlined);
      case 'audio': return const Icon(Icons.audiotrack_outlined);
      case 'pdf'  : return const Icon(Icons.picture_as_pdf_outlined);
      default     : return const Icon(Icons.insert_drive_file_outlined);
    }
  }
}
```

> **Ny fil** `lib/features/courses/presentation/course_player.dart` – elev‑visning med paywall

```dart
// lib/features/courses/presentation/course_player.dart
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:wisdom/features/courses/data/courses_repository.dart';
import 'package:wisdom/features/studio/data/studio_repository.dart';

class CoursePlayer extends StatefulWidget {
  final String courseId;
  final String lessonId;
  final String storageBucket; // 'public-media' | 'course-media'
  final String storagePath;   // "<courseId>/<lessonId>/..."
  final String kind;          // 'image'|'video'|'audio'|'pdf'|'other'

  const CoursePlayer({
    super.key,
    required this.courseId,
    required this.lessonId,
    required this.storageBucket,
    required this.storagePath,
    required this.kind,
  });

  @override
  State<CoursePlayer> createState() => _CoursePlayerState();
}

class _CoursePlayerState extends State<CoursePlayer> {
  final _courses = CoursesRepository();
  final _studio = StudioRepository();

  bool? _hasAccess;
  Uint8List? _data;
  String? _err;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    try {
      final ok = await _courses.hasAccess(widget.courseId);
      if (!mounted) return;
      if (!ok && widget.storageBucket == 'course-media') {
        setState(() => _hasAccess = false);
        return;
      }
      final bytes = await _studio.downloadMedia(
        bucket: widget.storageBucket,
        path: widget.storagePath,
      );
      if (!mounted) return;
      setState(() {
        _hasAccess = true;
        _data = bytes;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() => _err = 'Fel: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_err != null) {
      return Center(child: Text(_err!, style: const TextStyle(color: Colors.red)));
    }
    if (_hasAccess == null) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_hasAccess == false) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: const [
            Icon(Icons.lock_outline, size: 40),
            SizedBox(height: 8),
            Text('Det här innehållet är låst. Köp kursen för att låsa upp.'),
          ],
        ),
      );
    }
    if (_data == null) {
      return const Center(child: CircularProgressIndicator());
    }

    // Minimal rendering: bild/PDF -> Image.memory; video/audio: visa placeholder (koppla video_player själv)
    switch (widget.kind) {
      case 'image':
        return Image.memory(_data!);
      case 'pdf':
        return const Center(child: Text('Visa PDF med valfri viewer – data finns i minnet.'));
      case 'video':
        return const Center(child: Text('Video: koppla video_player med bytes eller via lokal caching.'));
      case 'audio':
        return const Center(child: Text('Audio: koppla en audio‑spelare.'));
      default:
        return const Center(child: Text('Fil nedladdad – visa med lämplig viewer.'));
    }
  }
}
```

> (Valfritt) `lib/features/studio/presentation/studio_page.dart` – enkel teacher‑gate

```dart
// lib/features/studio/presentation/studio_page.dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class StudioPage extends StatelessWidget {
  const StudioPage({super.key});

  Future<bool> _isTeacher() async {
    try {
      final res = await Supabase.instance.client.rpc('user_is_teacher');
      if (res is bool) return res;
    } catch (_) {}
    return false;
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<bool>(
      future: _isTeacher(),
      builder: (context, snap) {
        if (!snap.hasData) {
          return const Scaffold(body: Center(child: CircularProgressIndicator()));
        }
        if (snap.data != true) {
          return const Scaffold(body: Center(child: Text('Endast lärare har tillgång till Studio.')));
        }
        return const Scaffold(
          body: Center(child: Text('Studio – lägg in din CourseEditorPage i routern.')),
        );
      },
    );
  }
}
```

---

## 4) Snabb checklista (gör detta nu)

1. Kör **båda SQL‑migrationerna** i Supabase.
2. Säkerställ att ditt konto har **lärarroll** (JWT app_metadata.role = `teacher` eller rad i `teacher_permissions_compat` / `profiles.role_v2='teacher'`).
3. Lägg till `file_picker` i `pubspec.yaml` och kör `flutter pub get`.
4. Starta appen. I `CourseEditorPage`: slå på **Intro** för gratis media → laddas till `public-media`. Slå av för **betalt** → `course-media`.
5. I elev‑visning (`CoursePlayer`) – betalt material kräver inloggning och **köp**. Gratis intro visas alltid.

---

- 2025-09-30: Implementerat `/claim`-flöde i Flutter (GoRouter, Login redirect och ClaimPurchasePage) samt uppdaterat PaymentsService för `claim_purchase`/`can_access_course`. UI hindrar nu köpknappen när åtkomst redan finns.
- 2025-09-30: Synkade `init_projectapp.sql` med Phase A (user_role, purchases/guest_claim_tokens, pro_requirements, claim_purchase RPC).

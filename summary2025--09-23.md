Kodgranskning av Visdom-projektet
Sammanfattning av nuvarande tillstånd

Visdom är en Flutter-baserad mobilapp skriven i Dart, med en backend-integration via Supabase för autentisering och datalagring. Projektet är under aktiv utveckling och grundfunktionaliteten för inloggning, kontohantering och kursskapande finns på plats, men flera delar är ofärdiga eller behöver förbättras. Kodbasen är strukturerad i en feature-baserad arkitektur (med moduler som auth, teacher, subscribe etc.) samt gemensamma delar under core/ för t.ex. tema och verktyg. Detta upplägg är i stort sett enligt Flutter-konventioner, men det finns vissa inkonsekvenser i filstruktur och namngivning. Projektet använder moderna ramverk som Riverpod för state management och go_router för navigation
GitHub
, samt är uppdaterat till Flutter 3.x. Samtidigt finns tydliga områden att åtgärda: några funktionella buggar (t.ex. ofullständigt lösenordsåterställningsflöde), kodstilsbrister (många lint-varningar och äldre idiom), förbättringspotential i arkitektur och komponentisering, vissa säkerhetsaspekter kring hemligheter och validering, samt prestandafrågor (som avsaknad av caching/loading-indikatorer). Nedan följer en genomgång per kategori av identifierade problem, följt av rekommenderade steg för att åtgärda dem.

Identifierade problem
1. Funktionella buggar och fel

Lösenordsåterställning och deep-links: Appens flöde för “glömt lösenord” är inte fullt fungerande i nuläget. Specifikt saknas korrekt hantering av Supabase-återställningslänkar via deep linking. Det finns ingen global lyssnare på autentiseringshändelser eller definierad route för att fånga upp passwordRecovery-eventet, vilket gör att användaren inte automatiskt leds till sidan för att välja nytt lösenord
GitHub
. Detta innebär att återställningslänkar från e-post inte fungerar som avsett i dev-miljön (varken på webb eller mobil) utan extra åtgärd.

Omdirigering efter återställning: Relaterat till ovan saknas även en route för att hantera callback-URL:er. Det finns ingen /auth-callback route som omdirigerar till rätt vy, vilket på webben gör att lösenordsåterställningsflödet inte fullföljs
GitHub
.

Felhantering i UI: Tidigare versioner av appen visade råa felmeddelanden eller lämnade användaren utan feedback vid fel (t.ex. nätverksfel eller timeout från Supabase). Detta är både en UX-brist och en funktionell bugg då användaren inte informeras korrekt. Det finns behov att fånga upp fel (t.ex. Postgrest-timeouts/null-svar) och istället visa “skeleton”-skärmar eller användarvänliga meddelanden
GitHub
. Utan denna hantering riskerar appen att upplevas hänga eller visa obegriplig feltext.

Byggkontext efter async: Koden innehåller situationer där BuildContext används efter asynkrona anrop utan kontroll, vilket kan orsaka runtime-fel om widgeten hunnit tas bort. Linten use_build_context_synchronously flaggar detta problem
GitHub
. Om det inte åtgärdas kan exempelvis navigering eller SnackBar-visning efter en await krascha appen eller helt enkelt utebli, vilket är ett funktionellt fel.

Övriga logiska brister: Vissa flöden som prenumeration (Subscribe) och medlemskapsuppdateringar är inte fullt implementerade. T.ex. nämns att SubscribeScreen ännu inte skapar riktiga ordrar eller uppdaterar användarens medlemskap i backend
GitHub
. Dessutom tycks viss affärslogik vara halvfärdig – t.ex. kontroll av lärarroll vs. elevroll och filtrering av innehåll baserat på behörighet. Dessa ofärdiga delar kan leda till fel eller saknad funktionalitet i användarflödet tills de är fullbordade.

2. Kodstil och struktur (Dart/Flutter-konventioner)

Lint-varningar och inkonsekvent stil: Projektet har ett flertal stilvarningar enligt Dart’s lints. Bland annat används inte const där det är möjligt, listor skapas inte som immutables, många variabler är inte final trots att de aldrig ändras, och onödiga Container-widgets används istället för mer passande widgets eller parametrar
GitHub
. Dessa varningar – såsom prefer_const_constructors, prefer_final_fields, avoid_unnecessary_containers – indikerar att koden inte fullt ut följer rekommenderade Dart/Flutter-mönster, vilket kan påverka läsbarhet och prestanda.

Föråldrade API-anrop: Kodbasen använder vissa äldre eller deprecated Flutter-API:er. Ett tydligt exempel är knapp- och radiokomponenter som stilas med gamla metoder som ElevatedButton.styleFrom och direkt användning av MaterialStateProperty*, istället för att använda moderna Material 3-teman eller nya helper-funktioner
GitHub
. Även hantering av Radio-knappar sker med deprecated egenskaper (t.ex. direkt fillColor). Att behålla föråldrade anrop strider mot konventionerna och kan leda till varningar samt sämre framtidssäkerhet.

Kodkommentarer och naming: Generellt följer namngivning av klasser och filer Dart-konvention (t.ex. UpperCamelCase för klasser). Dock finns viss inkonsekvens i filnamn: i tasks dokumentationen nämns t.ex. både teacher_course_editor.dart och course_editor.dart för samma fil, vilket antyder att det kan finnas oenhetlig namngivning eller kvarvarande gamla filreferenser. Koden blandar svenska och engelska i variabel- och metodnamn på sina ställen (t.ex. textsträngar är svenska medan vissa kodenheter är engelska), men detta är mest en stilfråga – viktigt är att hålla enhetlighet i projektet.

Kodsammansättning: På vissa ställen är koden onödigt komplex eller svårläst. Exempelvis nämns i to-do att man bör omsluta enradiga if/else-satser med { }-block
GitHub
 för tydlighet. Vidare planeras refaktorisering för att göra om stora widget-träd med “blockifiering”, vilket tyder på att nuvarande implementeringar kan ha långa kedjor av inbäddade widgets som skulle må bra av att extraheras till mindre byggstenar. Sammantaget följer inte all kod helt idiomatisk Flutter-stil just nu, vilket kan göra underhållet svårare.

3. Projektarkitektur och strukturering

Modulindelning: Projektet är delat i features (funktionalitetsmoduler) och core (delad kärnlogik), vilket i grunden är bra. Till exempel finns moduler som auth/, teacher/, subscribe/, home/ under lib/features, och gemensamma komponenter under lib/core (t.ex. core/widgets/, core/utils/, core/theme/). Denna komponentisering följer vedertagna Flutter-strukturer för större appar. Dock verkar det finnas inkonsistenser i struktureringen. Vissa skärmar ligger t.ex. under lib/ui/pages/ eller lib/screens/ utanför features-trädet
GitHub
GitHub
 – t.ex. en landing_page.dart under ui/pages eller screens/landing/, parallellt med att liknande sidor (t.ex. login, signup) ligger under features/auth. Likaså finns lib/data/providers.dart separat, istället för inom en tydlig modul. Denna blandning kan förvirra utvecklare om var viss kod hör hemma.

Ansvarsfördelning: Det framgår av koden och tasks att logik finns både i UI-lager och i separata tjänster, men gränsen är inte alltid glasklar. T.ex. hanteras vissa autentiseringsflöden direkt i widgetar via Supabase-SDK:n, istället för att helt abstraheras i en service eller provider. Samtidigt nämns existensen av Repository-klasser som TeacherRepo och tjänster som StudioService för datalagring
GitHub
, dock verkar dessa duplicera funktionalitet (t.ex. två parallella representations av kursdata i public.courses vs app.courses). Arkitekturen behöver konsolideras så att varje källa av sanning är unik – just nu finns tecken på viss dubblering av datahanteringslogik, vilket ökar underhållsbördan.

Delad kod och utils: Flera verktyg saknas eller är inte centralt definierade, vilket leder till spridd ad-hoc-implementation. Exempel: man har identifierat behov av en global navigeringshelper efter async (ContextSafeNav) för att undvika mounted-problematiken, samt gemensamma padding- och styling-konstanter
GitHub
. Att dessa saknas tyder på att liknande kod skrivits på flera ställen (t.ex. repetitiva EdgeInsets eller navigeringsmönster) istället för att finnas i en central utility. Arkitekturellt planeras detta åtgärdas genom att införa nya filer i core/utils/ och core/ui/ (t.ex. context_safe.dart, ui_consts.dart, controls.dart) som samlar sådana gemensamma delar
GitHub
. Nuvarande avsaknad av dessa util-filer är en svaghet i arkitekturen, då det kan finnas duplikatkod och inkonsekvent användning av t.ex. marginaler eller knappstilar.

Routing och state-hantering: Appen använder go_router för navigation, och Riverpod för state, vilket är en modern arkitektur. En Router-konfiguration finns (troligen i lib/core/routing/app_router.dart) men den behövde utökas för att täcka nya skärmar som återställningslösen etc.
GitHub
. State management via Riverpod innebär att logik sannolikt ligger i providers – t.ex. för autentisering och dataladdning. Det är viktigt att se till att alla större features har tydligt separerade providers/controllers så UI-koden förblir ren. Om något, kan arkitekturen förbättras genom att striktare följa MVVM eller liknande, men i stort är grunden lagd.

4. Säkerhetsaspekter (hemligheter, validering m.m.)

Hantering av hemligheter: Projektet använder Supabase, vilket kräver en URL och en Anon Key för att fungera. Det är avgörande att dessa hemligheter hanteras säkert. I det nuvarande upplägget verkar man ha infört en .env-lösning för att lagra dessa värden utanför koden
GitHub
. Det är bra – man bör bekräfta att .env-filen inte är committad till källkoden och att lib/supabase_client.dart läser värdena därifrån vid runtime. Om nycklarna av misstag hårdkodats eller checkats in historiskt, bör de roteras omedelbart. Att hemligheter laddas på rätt sätt förbättrar säkerheten, och tasks nämner uttryckligen att .env-variablerna ska laddas i koden
GitHub
, vilket tyder på att utvecklaren är medveten om detta.

Autentisering och RLS: Då appen förlitar sig på Supabase Auth är det viktigt att rollhantering och RLS (Row Level Security) i databasen är korrekt konfigurerade. Av dokumentationen framgår att en kontroll ska göras så att t.ex. en inloggad användare med lärarroll verkligen identifieras som lärare i appen (ex via app.profiles.role eller en permissions-tabell)
GitHub
. Just nu är denna logik troligen inte komplett – det nämns att man måste verifiera att användaren odenhjalm@outlook.com har rollen teacher och att hjälpfunktionen user_is_teacher() returnerar true
GitHub
. Om rollkontrollen brister kan obehöriga få åtkomst till lärarfunktioner. Detta måste testas och säkras, antingen i frontend eller via RLS i Supabase (helst båda).

Inputvalidering: Säkerhet innefattar även validering av användarinmatning. I synnerhet hantering av e-post och lösenord vid registrering/inloggning behöver robust validering. Nuvarande implementation saknade delvis detta – uppgifterna specificerar att e-postformat och minsta lösenordslängd (6 tecken) ska valideras
GitHub
. Utan dessa kontroller riskerar man att felaktiga eller osäkra data skickas till backend (t.ex. extremt korta lösenord som kan äventyra kontons säkerhet, eller felstavade e-post som leder till borttappade återställningslänkar). Validering bör ske både i frontend (för bättre UX) och dubbelkollas i backend.

Fel- och undantagshantering: Som nämnt under buggar behöver alla fel fallhanteras. Ur säkerhetssynpunkt är det viktigt att intern information inte exponeras. Att appen nu uppdateras så att inga råa felmeddelanden visas för användaren
GitHub
 är positivt – det förhindrar att potentiellt känsliga uppgifter (t.ex. stacktraces eller SQL-fel) läcker ut. Istället kommer generella felmeddelanden eller “snälla” meddelanden visas, vilket höjer säkerheten och användarupplevelsen.

Övrigt: Inga uppenbara tecken på farliga mönster som hårdkodade API-nycklar (förutom Supabase), användning av osäkra http istället för https osv. Dock bör man vara uppmärksam på paketberoenden ur säkerhetssynpunkt – t.ex. se till att inga kända sårbarheter finns i versionerna av de paket som används (mer om det nedan). Sammantaget handlar säkerhetsarbetet mest om att följa best practices: lagra hemligheter säkert, validera indata ordentligt, och se till att behörighetskontroller både i frontend och backend är vattentäta.

5. Prestanda och effektivitet

Onödig rendering och widgetar: Kodstilsproblemen med brist på const och överanvändning av Container påverkar även prestandan. Utan const på statiska widgetar tvingas ramverket skapa om objekt i onödan vid varje rebuild, vilket kan ge sämre effektivitet. Att åtgärda dessa lint-varningar (markera oföränderliga widgets som const, göra variabler final etc.) kommer att trimma bort en del onödig arbete i UI-trädet
GitHub
. Även att ta bort unnecessary containers och direkt använda e.g. Padding eller SizedBox där det passar minskar djupet i widget-trädet och gör layoutrendering lite snabbare.

Laddningsindikatorer (Skeleton UI): Prestanda handlar inte bara om faktisk hastighet utan också upplevd hastighet. För närvarande verkar appen sakna “skeleton screens” på flera ställen, vilket gör att användaren kan mötas av tomma ytor eller blockande spinners under dataladdning. Planen är att införa skelettskärmar, t.ex. skelettkort på landningssidan medan data från Supabase laddas
GitHub
, samt ett video-placeholder i kursintro istället för en tom videospelare tills videon är redo
GitHub
. Dessa förändringar förbättrar upplevd prestanda avsevärt – appen känns snabbare och mer responsiv eftersom användaren alltid ser något meningsfullt. Just nu, utan dessa, kan appen kännas trög om nätverket är långsamt.

Bilder och media: Appen hanterar användaruppladdade bilder (avatarer) och videostreams för kurser. Prestandamässigt är caching av dessa media viktigt. Det nämns en kommande prestation att införa bildcache
GitHub
, vilket antyder att i nuläget kanske alla bilder hämtas varje gång och inte lagras lokalt eller i minnet. Avsaknad av caching kan göra appen datahungrig och seg vid upprepade visningar av samma innehåll. Likaledes bör videohanteringen (som nu sköts via video_player i CourseVideo-widgeten) säkerställa att videor pausas/disponeras när de inte är i bild, för att inte käka CPU eller batteri i onödan.

Datahämtning och asynkrona anrop: Att använda Supabase innebär nätverksanrop för t.ex. kurser, profiler m.m. Det är oklart hur effektivt detta är implementerat just nu. Man bör kontrollera att onödigt många anrop inte sker dubbelt, att realtidslyssnare inte läcker minne, och att storskaliga frågor begränsas (t.ex. genom filters/paginering) så inte appen försöker ladda för mycket data åt gången. Inga konkreta bevis på dålig prestanda här framkom i genomgången, men det är ett område att hålla under uppsikt. Ett positivt tecken är att man använder GoRouterRefreshStream kopplat till Supabase auth-händelser
GitHub
 för att effektivt trigga omdirigeringar – det visar på ett event-drivet tänk som kan vara resurseffektivt.

Uppstartstid: Med flera tunga paket (Supabase, Stripe för betalningar, videospelare mm.) finns risk att appens binär blir stor och uppstarten lite långsammare. Ingen explicit klagan på detta finns nu, men prestanda kan optimeras genom att bara initiera tjänster när de behövs (lazy loading). T.ex. bör man initiera Stripe först när man faktiskt ska visa betalningsvyn. Givet att appen ännu är i dev-stadiet är detta inte kritiskt, men inför framtida mobilrelease är det värt att beakta.

6. Beroenden (paketversioner och tyngd)

Uppdateringsläge: Projektet använder flera externa paket: supabase_flutter för backend, flutter_riverpod för state, go_router för navigering, video_player, eventuellt flutter_stripe för betalningar, m.m. Det är viktigt att dessa hålls uppdaterade. I dokumentationen ser vi hänvisningar till nyare funktioner (PKCE i Supabase, Material 3 stöd), vilket tyder på att relativt moderna versioner används. Däremot bör man regelbundet kolla om nyare versioner kommit med buggfixar eller säkerhetsförbättringar. Till exempel, Supabase SDK:n uppdateras ofta – om projektet ligger på en äldre 1.x-version kan det sakna fixar. Detsamma gäller Riverpod (v2 är standard nu) och go_router (v6 är aktuell). Inget tyder på att man sitter fast på en gammal Flutter-version; snarare uppges projektet använda Flutter 3.x
GitHub
, vilket är bra. Men i skrivande stund (2025) bör man säkerställa kompatibilitet med Flutter 3.13+ eller 4.0 om det släppts.

Föråldrade paket: En snabb genomgång hittar inga uppenbart utdaterade eller övergivna paket i användning – alla nämnda är populära och aktivt underhållna. Man bör dock kontrollera om det finns beroenden som inte används längre. I och med utvecklingsprocessen kan vissa paket ha lagts till för test men sedan inte kommit till användning. Dessa bör då tas bort från pubspec.yaml för att minimera appens storlek och komplexitet.

Tunga bibliotek: Bland de använda är Supabase ett ganska omfattande bibliotek (inklusive Postgrest, Auth, Storage klienter etc.), men det är nödvändigt för funktionaliteten. Flutter_Stripe (om det integreras för PaymentSheet) kan öka appstorleken markant då det inkluderar Stripes SDK; dock är betalningsfunktionaliteten antagligen central, så det får accepteras. video_player drar in nativa video-kodare, vilket också ökar storlek, men återigen uppvägs det av att videostöd är ett krav. Det finns inga direkt “onödigt tunga” paket som sticker ut – alla fyller en funktion. Optimeringen ligger snarare i att använda dem rätt (som nämnts: initialisera vid behov, inte tidigare).

Potentiella säkerhetsrisker i beroenden: Det är god praxis att kolla t.ex. via dart pub outdated eller genom Githubs varningar om någon dependency har kända sårbarheter. Särskilt paket som hanterar nätverk och auth (Supabase) eller betalningar (Stripe) bör hållas på senaste patch-nivå. Just nu finns inga kända röda flaggor, men fortsatt uppsikt krävs.

Sammanfattningsvis är beroendesituationen under kontroll, men utvecklarna bör planera in regelbundna uppdateringar. Ibland kan även en minor-uppdatering av Flutter SDK själv ge prestanda- eller säkerhetsförbättringar. Att då uppdatera och köra alla testfall/lintar är viktigt för att inte halka efter.

Rekommenderade åtgärder

För att förbättra projektet och lösa ovanstående problem föreslås följande steg:

Åtgärda funktionella buggar: Implementera det fullständiga lösenordsåterställningsflödet. Detta innefattar att lägga till en global auth-lyssnare (Supabase.instance.client.auth.onAuthStateChange) och hantera passwordRecovery-eventet genom att navigera användaren till en ny lösenordssida
GitHub
. Skapa nödvändiga rutter, t.ex. /auth-callback (som omdirigerar till /reset-password) och en sida /reset-password där användaren kan ange sitt nya lösenord
GitHub
. Testa att en återställningslänk som öppnas (både på web och mobil) faktiskt tar användaren till rätt vy i appen. Utöver detta, se över andra ofullständiga flöden: säkerställ t.ex. att Subscribe-funktionaliteten anropar backend (eller mock) för att skapa order och uppdatera medlemskap när det är dags. Alla större användarresor (login → hem, lärarens kursredigering, köpflöde etc.) ska testas från början till slut så att inga stoppklossar finns.

Förbättra felhantering och användarfeedback: Inför enhetlig hantering av fel och laddningstillstånd i hela appen. Använd try/catch runt nätverks- och auth-anrop och presentera användarvänliga felmeddelanden (gärna på svenska) istället för råa exception-texter
GitHub
. Implementera “Skeleton screens” eller placeholders där data laddas – t.ex. skelettkort på landningssidan och en grå videoruta innan videospelaren laddat
GitHub
 – så att appen aldrig visar tomma vyer. Detta kräver att man skapar widgetar för dessa loading-states och integrerar dem i UI-logiken (t.ex. visa skeleton om data==null och inga fel, visa felmeddelande-widget om fel!=null). Kontrollera också att inga use_build_context_synchronously-problem kvarstår: använd den nya ContextSafeNav-helpern eller checka mounted innan navigator/snackbar anrop efter async, för att undvika krashar.

Städa kodstil och följ Dart/Flutter-konventioner: Kör flutter analyze och adressera samtliga varningar. Gör en genomgång modul för modul och applicera de förbättringar som redan planerats: markera statiska widgets som const, använd literal-konstantsyntax för listor och maps, deklarera klassfält som final där det är möjligt, och ta bort onödiga Container-omslag
GitHub
. Inför även kodstilsregler som alltid använda { } kring villkorssatser även om de är enradiga – detta kan automatiseras delvis med dart fix. Uppdatera äldre sätt att anropa Material-komponenter: ersätt t.ex. ElevatedButton.styleFrom(...) med antingen ThemeData (globala tema-inställningar) eller nya ButtonStyle-helpers enligt Material 3-standard
GitHub
. Samma sak för radioknappar – använd en modern RadioThemeData istället för att sätta färg per komponent. Efter denna städning kommer koden vara mer idiomatisk, lättare att läsa och framtidssäker mot kommande SDK-uppdateringar.

Förstärk arkitekturen och struktureringen: Rensa upp filstrukturen så att liknande komponenter bor på konsistenta ställen. Överväg att avveckla mappen lib/ui/pages/lib/screens genom att flytta t.ex. landing_page in under en lämplig feature (kanske home/ feature) eller till core/ om den är allmängiltig. Detsamma gäller data/providers.dart – bryt upp den i feature-specifika providers eller lägg under core/ ifall det är globala provider-singletons. Inför de planerade hjälpfilerna: implementera ContextSafeNav-extension i core/utils/context_safe.dart och ersätt alla ställen där Navigator används efter async med dessa säkra metoder. Lägg in en central konfiguration av storlekskonstanter i core/ui/ui_consts.dart och använd dem överallt i UI:t (padding, gaps, corner radius) för konsekvent design
GitHub
. Vidare, konsolidera datalagringslogiken: om det finns dubbletter av kurs- eller profilhämtning i olika klasser, slå ihop dem eller tydliggör ansvarsfördelningen (t.ex. en CourseRepository som används både av elev- och lärarvyer istället för separata implementationer). Se också till att utnyttja Riverpod fullt ut – t.ex. att alla skärmar använder providers för att hämta data och utföra mutationer, istället för att direkt anropa Supabase-klienten i widgetkoden. Detta gör det enklare att testa och underhålla logiken framöver.

Säkerställ säkerhet och validering: Fortsätt arbetet med hemligheterna genom att verifiera att .env-hanteringen fungerar i alla miljöer (dev/prod) och att inga nycklar finns i repot. Lägg till rutin att alltid använda environment variables eller secure storage för liknande känsliga uppgifter (t.ex. Stripe API-nycklar, om sådana behövs, ska heller inte hårdkodas). Inför formulärvalidering för alla relevanta inmatningar: e-post, lösenord, namn etc., både i frontend (via FormField.validator) och dubbelkolla i backend (Supabase RLS eller triggers) för att undvika felaktiga data
GitHub
. Implementera också kontroll av användarroller i gränssnittet – t.ex. göm eller inaktivera lärar-specifika funktioner för en användare som inte är lärare, även om de manuellt skulle försöka navigera dit. Testa behörigheter noga: logga in som olika roller och försök komma åt skyddade vyer. Alla sådana försök ska stoppas antingen i UI (t.ex. redirect till home) eller av backend (RLS-policy), helst båda. Slutligen, fortsätt förbättra felmeddelanden så att de inte läcker teknisk info – logga tekniska detaljer till konsol om nödvändigt, men visa generella “Något gick fel, försök igen” till användaren där det inte är ett valideringsfel.

Optimera prestanda och upplevelse: Utför en prestandupass på appen. Inför bildcaching mekanismer – för profilbilder och kursmedia kan ni använda CachedNetworkImage paket eller skriva en enkel cache med Image.memory efter första hämtningen. Kontrollera att videospelaren inte laddar videon förrän den visas (kanske använda lazy-loading om möjligt), och visa under tiden en snygg placeholders-bild eller ikon
GitHub
. Granska också animationsprestanda om sådana finns (t.ex. om ni använder Hero animations eller liknande över många objekt). Se till att inga stora computations sker på huvudtråden – långvariga operationer bör läggas på en Isolate eller åtminstone async:as. Kör gärna verktyget flutter profiler/DevTools för att identifiera eventuella rendering jank eller minnesläckor. Då appen växer med fler funktioner (meddelanden, notiser etc. planeras), överväg att införskaffa en strategi för lazy loading av moduler – t.ex. endast initialisera Stripe SDK när användaren går in i prenumerationsfliken första gången. Detta kan korta ned appens uppstartstid. Sammantaget bör målet vara att appen känns snabb och mjuk: inga drop frames vid scrollning, snabba navigeringstransitioner, och om något tar tid (nätverksanrop) så ska användaren alltid få feedback i form av skeleton eller loader.

Uppdatera och städa beroenden: Gå igenom pubspec.yaml och uppdatera alla paket till senaste kompatibla version. Kör flutter pub outdated för att se vad som ligger efter. Uppdatera sedan successivt och testkör – särskilt Supabase och Stripe SDK:er kan ha viktiga bugfixar. Ta bort eventuella paket som inte längre behövs för att hålla appen lätt. När Flutter själv uppdateras (nya minor versions), se till att migrera koden (t.ex. Material3-ändringar) så snart som möjligt – detta förhindrar att teknisk skuld byggs upp. Använd verktyg som Dependabot/GitHub alerts för att bevaka säkerhetsproblem i dependencies. Slutligen, inför gärna en rutin i teamet att titta på changelogs för de viktigaste paketen (Flutter releaser, Supabase updates, Riverpod etc.) vid varje sprintavslut, så att ni är medvetna om nyheter som kan utnyttjas eller problem som måste åtgärdas.

Genom att följa dessa steg kommer Visdom-projektet att bli mer robust, lättare att underhålla och bättre förberett för framtida utveckling och lansering. Med fixade buggar, renare kod, solid arkitektur, förbättrad säkerhet, god prestanda och uppdaterade beroenden lägger ni grunden för en stabil och framgångsrik mobilapp.